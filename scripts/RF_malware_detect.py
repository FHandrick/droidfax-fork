# Import the random forest package
from sklearn.ensemble import RandomForestClassifier 
import numpy
import random
import os
import sys
import string
import string.split

'''
feature storage structure:
    {appname:[feature value set 1[feature-value1,feature-value2,...,feature-valueN], feature value set 2[...],...,]}
'''

'''load general features'''
def load_generalFeatures(gfn):
    fh = file(gfn, 'r')
    if fh==None:
        raise IOError("error occurred when opening file " + gfn)
    contents = fh.readlines()
    fh.close()
    gfeatures=dict()
    for line in contents:
        line=line.lstrip().rstrip()
        items = split(line)
        assert len(items)==30
        appname = items[0]
        if items[0] not in gfeatures.keys():
            gfeatures[ appname ] = list()
        fvs = [float(x) for x in items[1:]]
        gfeatures[ appname ].append( fvs )
    # for multiple sets of feature values per app, compute and keep the averages only
    for app in gfeatures.keys():
        allsets = gfeatures[app]
        if len(allsets)<2:
            print >> sys.err, app + " has one set of general features only!"
            continue
        for j in range(0, len(allsets[0])):
            for k in range(1,len(allsets)):
                allsets[0][j] += allsets[k][j]
            allsets[0][j] /= (len(allsets)*1.0)
        del gfeatures[app]
        gfeatures[app] = allsets[0] // change to mapping: appname -> vector of average (element-wise) feature values
    return gfeatures

'''load ICC features'''
def load_ICCFeatures(iccfn):
    fh = file(iccfn, 'r')
    if fh==None:
        raise IOError("error occurred when opening file " + iccfn)
    contents = fh.readlines()
    fh.close()
    iccfeatures=dict()
    for line in contents:
        line=line.lstrip().rstrip()
        items = split(line)
        assert len(items)==8
        appname = items[0]
        if items[0] not in iccfeatures.keys():
            iccfeatures[ appname ] = list()
        fvs = [float(x) for x in items[1:]]
        iccfeatures[ appname ].append( fvs )
    # for multiple sets of feature values per app, compute and keep the averages only
    for app in iccfeatures.keys():
        allsets = iccfeatures[app]
        if len(allsets)<2:
            print >> sys.err, app + " has one set of ICC features only!"
            continue
        for j in range(0, len(allsets[0])):
            for k in range(1,len(allsets)):
                allsets[0][j] += allsets[k][j]
            allsets[0][j] /= (len(allsets)*1.0)
        del iccfeatures[app]
        iccfeatures[app] = allsets[0] // change to mapping: appname -> vector of average (element-wise) feature values
    return iccfeatures

'''load security features'''
def load_securityFeatures(secfn):
    fh = file(secfn, 'r')
    if fh==None:
        raise IOError("error occurred when opening file " + secfn)
    contents = fh.readlines()
    fh.close()
    secfeatures=dict()
    for line in contents:
        line=line.lstrip().rstrip()
        items = split(line)
        assert len(items)==87
        appname = items[0]
        if items[0] not in secfeatures.keys():
            secfeatures[ appname ] = list()
        fvs = [float(x) for x in items[1:]]
        secfeatures[ appname ].append( fvs )
    # for multiple sets of feature values per app, compute and keep the averages only
    for app in secfeatures.keys():
        allsets = secfeatures[app]
        if len(allsets)<2:
            print >> sys.err, app + " has one set of security features only!"
            continue
        for j in range(0, len(allsets[0])):
            for k in range(1,len(allsets)):
                allsets[0][j] += allsets[k][j]
            allsets[0][j] /= (len(allsets)*1.0)
        del secfeatures[app]
        secfeatures[app] = allsets[0] // change to mapping: appname -> vector of average (element-wise) feature values
    return secfeatures


def getTrainingData(featureDir):
    # these benign apps are found malicious by VirusTotal, will be excluded from the training data set
    malbenignapps=["com.ictap.casm", "com.aob", "com.vaishnavism.vishnusahasranaamam.english", "com.hardcoreapps.loboshaker"]

    gfeatures_benign = load_generalFeatures(featureDir+"/gfeatures.txt")
    iccfeatures_benign = load_ICCFeatures(featureDir+"/iccfeatures.txt")
    secfeatures_benign = load_securityFeatures(featureDir+"/securityfeatures.txt")

    diffapps_benign = set(gfeatures_benign.keys()).intsection(iccfeatures_benign.keys()).intersection(secfeatures_benign.keys())
    for app in set(malbenignapps).union(diffapps_benign):
        del gfeatures_benign[app]
        del iccfeatures_benign[app]
        del secfeatures_benign[app]

    assert len(gfeatures_benign)==len(iccfeatures_benign) && len(iccfeatures_benign)==len(secfeatures_benign)

    benignLabels=[]
    for j in range(0,len(gfeatures_benign)):
        benignLabels.append("BENIGN")

    diffapps_malware = \
        set(gfeatures_malware.keys()).intersection(iccfeatures_malware.keys()).intersection(secfeatures_malware.keys())

    gfeatures_malware = load_generalFeatures(featureDir+"/gfeatures-malware.txt")
    iccfeatures_malware = load_ICCFeatures(featureDir+"/iccfeatures-malware.txt")
    secfeatures_malware = load_securityFeatures(featureDir+"/securityfeatures-malware.txt")
    for app in diffapps_malware:
        del gfeatures_malware[app]
        del iccfeatures_malware[app]
        del secfeatures_malware[app]

    malwareLabels=[]


train_data=numpy.random.random((3,5))
print "TRAINING DATA"

# Create the random forest object which will include all the parameters
# for the fit
forest = RandomForestClassifier(n_estimators = 100)

# Fit the training data to the Survived labels and create the decision trees
#forest = forest.fit(train_data[0::,1::],train_data[0::,0])
Y=[1,0,1]
forest = forest.fit(train_data[0::,0::], Y)

print "PREDICTION INPUT"
test_data=numpy.random.random((30,5))
print test_data

# Take the same decision trees and run it on the test data
output = forest.predict(test_data)
print "PREDICTION RESULTS"
print output
print "PREDICTION SCORE"
print forest.score(test_data, numpy.ones(len(test_data)))
